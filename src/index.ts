// migrate(): 渡されたドキュメント一式に対してマイグレーションを実行する
//   options:
//     - skipValidation: 全ドキュメントに対するマイグレーションが成功するかのチェックをスキップする
//     - migrationPath: マイグレーション定義の格納されたパス
//     -

// パラメータ
// - マイグレーション定義のパス
// - versionedDocs: JSONドキュメント一式(それぞれにバージョンが含まれている想定)
// -

// 想定するシチュエーション
// - 全ドキュメントに対し一括でマイグレーションの適用が可能(centerized)
//     - マイグレーションをどこまで適用したかは1箇所で管理できる
//     - 入力はマイグレーション定義のパスと、バージョンを取得する方法
// - クライアントサイドなど、ユーザーによってドキュメントのバージョンが異なる可能性がある (per document)
//     - バージョン情報は各ドキュメントに含まれている必要がある
//     - 入力はマイグレーション定義のパスと、ドキュメント一式
// マイグレーションのストラテジーとして上記2つを実行できるようにする

// マイグレーションの流れ(per document)
// - マイグレーション定義、バージョン取得関数を受け取ることを期待
// - マイグレーションをループで実行
//     - バージョン取得関数でバージョンを特定
//         - 処理不要な場合はスキップする
//     - スクリプトからマイグレーション関数をimportして実行する。パラメータには成功した時用にバージョン番号を含める
//         - 内部でドキュメントの更新まで行う想定
//         - 処理成功したらスクリプト側でバージョンを更新する
// - 途中でエラーが起きた場合は、その時点でロールバックすることを標準動作にする
//     - エラーの発生したドキュメントが分かる情報をログ出力する

// ロールバックの流れ
// - マイグレーション定義、バージョン取得関数、戻す先のバージョンを受け取ることを期待
// - マイグレーション一覧を逆順でループ実行
//     - 戻し先のバージョンと同じ場合はその時点で処理を中断する
//     - スクリプトからロールバック関数を受け取って実行する。パラメータには成功したと時用にバージョン番号を含める
//     - 処理成功したらスクリプト側でバージョンを更新する

// 途中で失敗した場合をなるべく保護したい件
//    - 理想は実行前のバックアップをとっておく
//        - この場合の懸念は、対象が膨大な場合に保存が難しい。ただ、そんな件数を扱うことは稀とも思える
//        - もう一つは、バックアップしたドキュメントをどのドキュメントに適用するか判断が必要な点
//            - マイグレーション実行時にバックアップを作成する際、何らかのキーを決めておけば、それを元に戻すドキュメントを特定できる
//            - バックアップのキー名とリストア用の関数をexportした場合、その情報を元にロールバックする実装にしておけば、どちらの方法でも運用できる
