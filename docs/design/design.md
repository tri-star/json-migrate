## 想定するシチュエーション

マイグレーションのストラテジー(Version strategy)として以下の 2 つを実行できるようにする

- centerized: 全ドキュメントに対し一括でマイグレーションの適用が可能
  - マイグレーションをどこまで適用したかは 1 箇所で管理できる
  - 入力はマイグレーション定義のパスと、バージョンを取得する方法
- per document: クライアントサイドなど、ユーザーによってドキュメントのバージョンが異なる可能性がある
  - バージョン情報は各ドキュメントに含まれている必要がある
  - 入力はマイグレーション定義のパスと、ドキュメント一式

## マイグレーションの流れ(per document)

- マイグレーション定義、バージョン取得関数を受け取ることを期待
- マイグレーションをループで実行
  - バージョン取得関数でバージョンを特定
    - 処理不要な場合はスキップする
  - スクリプトからマイグレーション関数を import して実行する。パラメータには成功した時用にバージョン番号を含める
    - 内部でドキュメントの更新まで行う想定
    - 処理成功したらスクリプト側でバージョンを更新する
- 途中でエラーが起きた場合は、その時点でロールバックすることを標準動作にする
  - エラーの発生したドキュメントが分かる情報をログ出力する
    ロールバックの流れ
- マイグレーション定義、バージョン取得関数、戻す先のバージョンを受け取ることを期待
- マイグレーション一覧を逆順でループ実行
  - 戻し先のバージョンと同じ場合はその時点で処理を中断する
  - スクリプトからロールバック関数を受け取って実行する。パラメータには成功したと時用にバージョン番号を含める
  - 処理成功したらスクリプト側でバージョンを更新する

## 途中で失敗した場合をなるべく保護したい件

- 理想は実行前のバックアップをとっておく
  - この場合の懸念は、対象が膨大な場合に保存が難しい。ただ、そんな件数を扱うことは稀とも思える
  - もう一つは、バックアップしたドキュメントをどのドキュメントに適用するか判断が必要な点
    - マイグレーション実行時にバックアップを作成する際、何らかのキーを決めておけば、それを元に戻すドキュメントを特定できる
    - バックアップのキー名とリストア用の関数を export した場合、その情報を元にロールバックする実装にしておけば、どちらの方法でも運用できる

## ライブラリが export する関数とパラメータ

- type MigrationStrategy: 'centerized' | 'per_document'
- type MigrationDefinition<T extends MigrationStrategy>
  = T extends centerized ? CenterizedMigrationDefinition
  : PerDocumentMigrationDefinition - バージョンを取得する関数 - バックアップキー(optional) - リストア関数(optional) - migrate 関数
- type MigrationOption

  - centerized の場合の現在のバージョンを取得するための関数

- ## migrate<T extends MigrationStrategy>(strategy: T, definitions: MigrationDefinition<T>[], options?: MigrationOption)

## CLI ツールの案

- マイグレーション実行コマンド
- ロールバックコマンド
- 新規マイグレーションファイル作成
